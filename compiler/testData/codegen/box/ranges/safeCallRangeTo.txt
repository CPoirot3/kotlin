MODULE <test-module>
  FILE /safeCallRangeTo.kt
    FUN public fun charRange(x: kotlin.Char?, y: kotlin.Char): kotlin.ranges.CharRange?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='charRange(Char?, Char): CharRange?'
          BLOCK type=kotlin.ranges.CharRange? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Char?
              GET_VAR 'value-parameter x: Char?' type=kotlin.Char? operator=null
            WHEN type=kotlin.ranges.CharRange? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Char?' type=kotlin.Char? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Char): CharRange' type=kotlin.ranges.CharRange operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Char?' type=kotlin.Char? operator=null
                other: GET_VAR 'value-parameter y: Char' type=kotlin.Char operator=null
    FUN public fun byteRange(x: kotlin.Byte?, y: kotlin.Byte): kotlin.ranges.IntRange?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='byteRange(Byte?, Byte): IntRange?'
          BLOCK type=kotlin.ranges.IntRange? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Byte?
              GET_VAR 'value-parameter x: Byte?' type=kotlin.Byte? operator=null
            WHEN type=kotlin.ranges.IntRange? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Byte?' type=kotlin.Byte? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Byte): IntRange' type=kotlin.ranges.IntRange operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Byte?' type=kotlin.Byte? operator=null
                other: GET_VAR 'value-parameter y: Byte' type=kotlin.Byte operator=null
    FUN public fun shortRange(x: kotlin.Short?, y: kotlin.Short): kotlin.ranges.IntRange?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='shortRange(Short?, Short): IntRange?'
          BLOCK type=kotlin.ranges.IntRange? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Short?
              GET_VAR 'value-parameter x: Short?' type=kotlin.Short? operator=null
            WHEN type=kotlin.ranges.IntRange? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Short?' type=kotlin.Short? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Short): IntRange' type=kotlin.ranges.IntRange operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Short?' type=kotlin.Short? operator=null
                other: GET_VAR 'value-parameter y: Short' type=kotlin.Short operator=null
    FUN public fun intRange(x: kotlin.Int?, y: kotlin.Int): kotlin.ranges.IntRange?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='intRange(Int?, Int): IntRange?'
          BLOCK type=kotlin.ranges.IntRange? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Int?
              GET_VAR 'value-parameter x: Int?' type=kotlin.Int? operator=null
            WHEN type=kotlin.ranges.IntRange? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Int?' type=kotlin.Int? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Int): IntRange' type=kotlin.ranges.IntRange operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Int?' type=kotlin.Int? operator=null
                other: GET_VAR 'value-parameter y: Int' type=kotlin.Int operator=null
    FUN public fun longRange(x: kotlin.Long?, y: kotlin.Long): kotlin.ranges.LongRange?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='longRange(Long?, Long): LongRange?'
          BLOCK type=kotlin.ranges.LongRange? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Long?
              GET_VAR 'value-parameter x: Long?' type=kotlin.Long? operator=null
            WHEN type=kotlin.ranges.LongRange? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Long?' type=kotlin.Long? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Long): LongRange' type=kotlin.ranges.LongRange operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Long?' type=kotlin.Long? operator=null
                other: GET_VAR 'value-parameter y: Long' type=kotlin.Long operator=null
    FUN public fun floatRange(x: kotlin.Float?, y: kotlin.Float): kotlin.ranges.ClosedRange<kotlin.Float>?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='floatRange(Float?, Float): ClosedRange<Float>?'
          BLOCK type=kotlin.ranges.ClosedRange<kotlin.Float>? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Float?
              GET_VAR 'value-parameter x: Float?' type=kotlin.Float? operator=null
            WHEN type=kotlin.ranges.ClosedRange<kotlin.Float>? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Float?' type=kotlin.Float? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Float) on Float: ClosedRange<Float>' type=kotlin.ranges.ClosedRange<kotlin.Float> operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Float?' type=kotlin.Float? operator=null
                that: GET_VAR 'value-parameter y: Float' type=kotlin.Float operator=null
    FUN public fun dougleRange(x: kotlin.Double?, y: kotlin.Double): kotlin.ranges.ClosedRange<kotlin.Double>?
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='dougleRange(Double?, Double): ClosedRange<Double>?'
          BLOCK type=kotlin.ranges.ClosedRange<kotlin.Double>? operator=SAFE_CALL
            VAR val tmp0_safe_receiver: kotlin.Double?
              GET_VAR 'value-parameter x: Double?' type=kotlin.Double? operator=null
            WHEN type=kotlin.ranges.ClosedRange<kotlin.Double>? operator=SAFE_CALL
              if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                arg0: GET_VAR 'tmp0_safe_receiver: Double?' type=kotlin.Double? operator=null
                arg1: CONST Null type=kotlin.Nothing? value='null'
              then: CONST Null type=kotlin.Nothing? value='null'
              else: CALL 'rangeTo(Double) on Double: ClosedRange<Double>' type=kotlin.ranges.ClosedRange<kotlin.Double> operator=null
                $this: GET_VAR 'tmp0_safe_receiver: Double?' type=kotlin.Double? operator=null
                that: GET_VAR 'value-parameter y: Double' type=kotlin.Double operator=null
    FUN public inline fun <reified T, R> testSafeRange(x: T, y: T, expectStr: kotlin.String, safeRange: (T?, T) -> R?): kotlin.Unit
      BLOCK_BODY
        VAR val rNull: R?
          CALL 'invoke(T?, T): R?' type=R? operator=INVOKE
            $this: GET_VAR 'value-parameter safeRange: (T?, T) -> R?' type=(T?, T) -> R? operator=VARIABLE_AS_FUNCTION
            p1: CONST Null type=kotlin.Nothing? value='null'
            p2: GET_VAR 'value-parameter y: T' type=T operator=null
        CALL 'assert(Boolean, () -> Any): Unit' type=kotlin.Unit operator=null
          value: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
            arg0: GET_VAR 'rNull: R?' type=R? operator=null
            arg1: CONST Null type=kotlin.Nothing? value='null'
          lazyMessage: BLOCK type=() -> kotlin.String operator=LAMBDA
            FUN local final fun <anonymous>(): kotlin.String
              BLOCK_BODY
                RETURN type=kotlin.Nothing from='<anonymous>(): String'
                  STRING_CONCATENATION type=kotlin.String
                    CALL '<get-simpleName>(): String?' type=kotlin.String? operator=GET_PROPERTY
                      $this: CLASS_REFERENCE '<reified T>' type=kotlin.reflect.KClass<T>
                    CONST String type=kotlin.String value=': Expected: null, got '
                    GET_VAR 'rNull: R?' type=R? operator=null
            CALLABLE_REFERENCE '<anonymous>(): String' type=() -> kotlin.String operator=LAMBDA
        VAR val rxy: R?
          CALL 'invoke(T?, T): R?' type=R? operator=INVOKE
            $this: GET_VAR 'value-parameter safeRange: (T?, T) -> R?' type=(T?, T) -> R? operator=VARIABLE_AS_FUNCTION
            p1: GET_VAR 'value-parameter x: T' type=T operator=null
            p2: GET_VAR 'value-parameter y: T' type=T operator=null
        CALL 'assert(Boolean, () -> Any): Unit' type=kotlin.Unit operator=null
          value: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
            arg0: BLOCK type=kotlin.String? operator=SAFE_CALL
              VAR val tmp0_safe_receiver: R?
                GET_VAR 'rxy: R?' type=R? operator=null
              WHEN type=kotlin.String? operator=SAFE_CALL
                if: CALL 'EQEQ(Any?, Any?): Boolean' type=kotlin.Boolean operator=EQEQ
                  arg0: GET_VAR 'tmp0_safe_receiver: R?' type=R? operator=null
                  arg1: CONST Null type=kotlin.Nothing? value='null'
                then: CONST Null type=kotlin.Nothing? value='null'
                else: CALL 'toString(): String' type=kotlin.String operator=null
                  $this: TYPE_OP operator=IMPLICIT_CAST typeOperand=kotlin.Any
                    GET_VAR 'tmp0_safe_receiver: R?' type=R? operator=null
            arg1: GET_VAR 'value-parameter expectStr: String' type=kotlin.String operator=null
          lazyMessage: BLOCK type=() -> kotlin.String operator=LAMBDA
            FUN local final fun <anonymous>(): kotlin.String
              BLOCK_BODY
                RETURN type=kotlin.Nothing from='<anonymous>(): String'
                  STRING_CONCATENATION type=kotlin.String
                    CALL '<get-simpleName>(): String?' type=kotlin.String? operator=GET_PROPERTY
                      $this: CLASS_REFERENCE '<reified T>' type=kotlin.reflect.KClass<T>
                    CONST String type=kotlin.String value=': Expected: '
                    GET_VAR 'value-parameter expectStr: String' type=kotlin.String operator=null
                    CONST String type=kotlin.String value=', got '
                    GET_VAR 'rxy: R?' type=R? operator=null
            CALLABLE_REFERENCE '<anonymous>(): String' type=() -> kotlin.String operator=LAMBDA
    FUN public fun box(): kotlin.String
      BLOCK_BODY
        CALL 'testSafeRange(Char, Char, String, (Char?, Char) -> CharRange?): Unit' type=kotlin.Unit operator=null
          x: CONST Char type=kotlin.Char value='0'
          y: CONST Char type=kotlin.Char value='1'
          expectStr: CONST String type=kotlin.String value='0..1'
          safeRange: CALLABLE_REFERENCE 'charRange(Char?, Char): CharRange?' type=kotlin.reflect.KFunction2<kotlin.Char?, kotlin.Char, kotlin.ranges.CharRange?> operator=null
        CALL 'testSafeRange(Byte, Byte, String, (Byte?, Byte) -> IntRange?): Unit' type=kotlin.Unit operator=null
          x: CONST Byte type=kotlin.Byte value='0'
          y: CONST Byte type=kotlin.Byte value='1'
          expectStr: CONST String type=kotlin.String value='0..1'
          safeRange: CALLABLE_REFERENCE 'byteRange(Byte?, Byte): IntRange?' type=kotlin.reflect.KFunction2<kotlin.Byte?, kotlin.Byte, kotlin.ranges.IntRange?> operator=null
        CALL 'testSafeRange(Short, Short, String, (Short?, Short) -> IntRange?): Unit' type=kotlin.Unit operator=null
          x: CONST Short type=kotlin.Short value='0'
          y: CONST Short type=kotlin.Short value='1'
          expectStr: CONST String type=kotlin.String value='0..1'
          safeRange: CALLABLE_REFERENCE 'shortRange(Short?, Short): IntRange?' type=kotlin.reflect.KFunction2<kotlin.Short?, kotlin.Short, kotlin.ranges.IntRange?> operator=null
        CALL 'testSafeRange(Int, Int, String, (Int?, Int) -> IntRange?): Unit' type=kotlin.Unit operator=null
          x: CONST Int type=kotlin.Int value='0'
          y: CONST Int type=kotlin.Int value='1'
          expectStr: CONST String type=kotlin.String value='0..1'
          safeRange: CALLABLE_REFERENCE 'intRange(Int?, Int): IntRange?' type=kotlin.reflect.KFunction2<kotlin.Int?, kotlin.Int, kotlin.ranges.IntRange?> operator=null
        CALL 'testSafeRange(Long, Long, String, (Long?, Long) -> LongRange?): Unit' type=kotlin.Unit operator=null
          x: CONST Long type=kotlin.Long value='0'
          y: CONST Long type=kotlin.Long value='1'
          expectStr: CONST String type=kotlin.String value='0..1'
          safeRange: CALLABLE_REFERENCE 'longRange(Long?, Long): LongRange?' type=kotlin.reflect.KFunction2<kotlin.Long?, kotlin.Long, kotlin.ranges.LongRange?> operator=null
        CALL 'testSafeRange(Float, Float, String, (Float?, Float) -> ClosedRange<Float>?): Unit' type=kotlin.Unit operator=null
          x: CONST Float type=kotlin.Float value='0.0'
          y: CONST Float type=kotlin.Float value='1.0'
          expectStr: CONST String type=kotlin.String value='0.0..1.0'
          safeRange: CALLABLE_REFERENCE 'floatRange(Float?, Float): ClosedRange<Float>?' type=kotlin.reflect.KFunction2<kotlin.Float?, kotlin.Float, kotlin.ranges.ClosedRange<kotlin.Float>?> operator=null
        CALL 'testSafeRange(Double, Double, String, (Double?, Double) -> ClosedRange<Double>?): Unit' type=kotlin.Unit operator=null
          x: CONST Double type=kotlin.Double value='0.0'
          y: CONST Double type=kotlin.Double value='1.0'
          expectStr: CONST String type=kotlin.String value='0.0..1.0'
          safeRange: CALLABLE_REFERENCE 'dougleRange(Double?, Double): ClosedRange<Double>?' type=kotlin.reflect.KFunction2<kotlin.Double?, kotlin.Double, kotlin.ranges.ClosedRange<kotlin.Double>?> operator=null
        RETURN type=kotlin.Nothing from='box(): String'
          CONST String type=kotlin.String value='OK'
